import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;


/**
 * This class was created on March 07, 2014 to resolve issues faced in the implementation of the larger MDPDecisionModelConfiguration
 * 
 *  This class does pretty much the same thing however it simplifies the states of the world by not defining as states 
 *  the <PortfolioAssetState,AssetWeight Tuple> pairs that the MDPCapitalMarketState does
 *  
 *   This class is also used within the current model framework as a global state of nature definition constructor that is owned by the Economy class
 *   and shared by all agents in the Economy.
 *   
 *   The Logic is that 
 *   1: the states set, action sets and successive current states are published to the agents by the Economy to the agents
 *   2: agents will own individual QLearningInvestorCalcualtorEngine and SolverAlgorithms which will consume the data generated by this class and allow the agents 
 *   to determine their best actions
 *   3: The agents' reward functions, initial actions, permissible next actions, and so on are housed in the QLearningInvestorCalcualtorEngine
 *   
 *   
 * @author Oluwasegun Bewaji
 *
 */
public class QLearningConfiguration {
	
	String decisionAnalysisPeriodEndString; //possible values "2003", "2007", "Full"
	int decisionAnalysisPeriod; // possible values 0, 1, 2
	double discountfactor; //the discount factor at which future payoffs will be discounted 
	List<AdjacencyMatrixContainer> JOINED_PROBABILITYMATRIX_LIST = new ArrayList<AdjacencyMatrixContainer>();//data collection on states information
	private List<List<AdjacencyMatrixContainer>> JOINED_PROBABILITYMATRIX_HISTORY = new ArrayList<List<AdjacencyMatrixContainer>>();
	double[] crdtPredefinedExpectedReturns;//data collection on expected returns on credit asset
	double[] eqtyPredefinedExpectedReturns;//data collection on expected returns on equity asset
	double riskFreeCashAssetReturn; //used to determine if model will use the choice of portfolio weights or the choice of changes in portfolio weights
	ArrayList<double[]> transitions;//collection of transition probabilities lists used to create each PortfolioAssetsState's
																//transitions to adjacent states
	ArrayList<PortfolioAssetsState> portfolioStates;//collection of PortfolioAssetsState objects 
																				  //used in creating the MDP states
	ArrayList<PortfolioWeights> weights;//collection of PortfolioAssetsState objects 
	  //used in creating the MDP states
	ArrayList<MDPPortfolioChoiceAction> actionsSpace; //collection of all actions available to chose from 
	
	ArrayList<MDPCapitalMarketsState> MDPStates;//collection of PortfolioAssetsState objects 
	//used in creating the MDP states
	ArrayList<ArrayList<MDPCapitalMarketsState>> MDPStatesHistoy;
	
	ArrayList<QValue> qValuesBull;
	ArrayList<QValue> qValuesBear;
	ArrayList<QValue> qValuesRational;


	
	boolean shortSelling = false; //determines if short selling is permitted in the model. It is defaulted to False
	boolean linearCostFunction = false; //determines if the model uses a linear cost function. It is defaulted to False
	boolean portfolioWeightChoiceModel;
	boolean stachasticTransitions;
	
	double linearfactor; //used as the constant parameter/multiplier for computing the linear transaction costs 
	double quadraticfactor; //used as the constant parameter/multiplier for computing the quadratic transaction costs
	double assetWieghtIncrements; //increment used to create the potfolio weights that are used to define the MDP states 
	double changeInWeightIncrement; //represents the rate at which changes can be made to portfolio weights 
	double maximumPermissbleChangeInWeight; //represents the maximum change in portfolio weights this will be the range from positive to negative
	public double rationalCreditDefaults;
	public double equityDefaults;
	public double bullCreditDefaults;
	public double bearCreditDefaults;
	public double passiveCreditDefaults;
	public double opportunityCostOfFixedIncomeInvestment;
	int numberOfEpochs;
	int rateResetWindow;
	
	
	MDPStatesPathEngine statesPathEngine; // this is used to generate the starting state and random path of states. 
	//It is treated as a separate class due to potential for complexity in functions
	

	TransitionProbabilitiesEngine tpEngine;
	
	
	//heavily used temporary variables in methods
	MDPCapitalMarketsState mdpS;
	MDPCapitalMarketsState mdpSP;
	PortfolioAssetsState ps;
	PortfolioAssetsState psp;
	PortfolioAssetsState mdpPsp;
	TreeSet<Transition> adjListTransition;
	Iterator<Transition> itr;
	Transition trans;
	double mdpSEW = 0;
	double mdpSCdW = 0;
	double mdpSChW = 0;
	double mdpSPEW = 0;
	double mdpSPCdW = 0;
	double mdpSPChw = 0;
	double eqtyDiff = 0;
	double crdtDiff = 0;
	double cshDiff  = 0;
	double zero = 0.0;
	double prob = 0;
	
	
	
	//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<CONSTRUCTOR>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	public QLearningConfiguration(TransitionProbabilitiesEngine tpEngine, MDPModelInputParameters RLModelParameters, int resetWindow, 
			double rationalCreditDefaults, double equityDefaults, double bullCreditDefaults, double bearCreditDefaults, double passiveCreditDefaults, 
			double opportunityCostOfFixedIncomeInvestment){
		this.portfolioStates = new ArrayList<PortfolioAssetsState>();
		this.weights = new ArrayList<PortfolioWeights>();
		this.transitions = new ArrayList<double[]>();
		this.actionsSpace = new ArrayList<MDPPortfolioChoiceAction>();
		MDPStates = new ArrayList<MDPCapitalMarketsState>();
		this.MDPStatesHistoy = new ArrayList<ArrayList<MDPCapitalMarketsState>>();
		//this will be a class construction called by the Economy class in the full simulation
		this.decisionAnalysisPeriodEndString = RLModelParameters.getDecisionAnalysisPeriodEndString();
		this.setPeriodEnd(this.decisionAnalysisPeriodEndString);
		this.riskFreeCashAssetReturn = RLModelParameters.getRiskFreeRate();
		this.shortSelling = RLModelParameters.isShortSelling();
		this.linearCostFunction = RLModelParameters.isLinearCostFunction();
		this.assetWieghtIncrements = RLModelParameters.getAssetWieghtIncrements();
		this.changeInWeightIncrement = RLModelParameters.getChangeInWeightIncrement();
		this.maximumPermissbleChangeInWeight = RLModelParameters.getMaximumPermissbleChangeInWeight();
		this.discountfactor = RLModelParameters.getGammaDiscountFactor();
		this.linearfactor = RLModelParameters.getLinearfactor();
		this.quadraticfactor = RLModelParameters.getQuadraticfactor();
		this.tpEngine = tpEngine;
		this.rationalCreditDefaults = rationalCreditDefaults;
		this.equityDefaults = equityDefaults;
		this.bullCreditDefaults = bullCreditDefaults;
		this.bearCreditDefaults = bearCreditDefaults;
		this.passiveCreditDefaults = passiveCreditDefaults;
		this.opportunityCostOfFixedIncomeInvestment = opportunityCostOfFixedIncomeInvestment;
		this.numberOfEpochs = RLModelParameters.getNumberOfDecisionEpochs();
		this.rateResetWindow = resetWindow;
		this.stachasticTransitions = RLModelParameters.isStochasticStateTransitions();

		//create the full set of states and actions
		this.initializeDefaultModel(tpEngine, stachasticTransitions, this.decisionAnalysisPeriodEndString, 
				this.shortSelling, RLModelParameters.getnumberOfIterations(), this.assetWieghtIncrements);
		
	}
	
	

	
	
	//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<CORE METHODS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	
	//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<CORE METHODS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	/**
	 * set the value of the predefined transition probability space
	 * this is for training purposes only JOINED_PROBABILITYMATRIX_LIST
	 * @param decisionAnalysisPeriod
	 */
	public void setPredefinedTransitionProbabilityMatrix(int decisionAnalysisPeriod){
		DefinedTransitionProbabilities definedTransitionProbabilities = new DefinedTransitionProbabilities();
		switch(decisionAnalysisPeriod){
		case 0://using market data from period 2000 to 2003
			definedTransitionProbabilities.setOMBAX_SP500_PROBABILITYMATRIXEnd2003();
			JOINED_PROBABILITYMATRIX_LIST = definedTransitionProbabilities.OMBAX_SP500_PROBABILITYMATRIXEnd2003;
			break;
		case 1://using market data from period 2004 to 2007
			definedTransitionProbabilities.setOMBAX_SP500_PROBABILITYMATRIXEnd2007();
			JOINED_PROBABILITYMATRIX_LIST = definedTransitionProbabilities.OMBAX_SP500_PROBABILITYMATRIXEnd2007;
			break;
		case 2://using market data from the full range of periods
			definedTransitionProbabilities.setOMBAX_SP500_PROBABILITYMATRIXEndFull();
			JOINED_PROBABILITYMATRIX_LIST = definedTransitionProbabilities.OMBAX_SP500_PROBABILITYMATRIXEndFull;
			break;
		default://default to using market data from period 2000 to 2003
			definedTransitionProbabilities.setOMBAX_SP500_PROBABILITYMATRIXEnd2003();
			JOINED_PROBABILITYMATRIX_LIST = definedTransitionProbabilities.OMBAX_SP500_PROBABILITYMATRIXEnd2003;
			break;
		}
	}
	
	
	/**
	 * set the value of the credit and equity expected return arrays based on evaluation period
	 * @param decisionAnalysisPeriod
	 */
	public void setDefaultAssetClassesExpectedReturns(int decisionAnalysisPeriod){
		switch(decisionAnalysisPeriod){
		case 0://using market data from period 2000 to 2003
			crdtPredefinedExpectedReturns = DefiinedStateReturns.OMBAX_ExpectedReturns2000_3;
			eqtyPredefinedExpectedReturns = DefiinedStateReturns.SP500_ExpectedReturns2000_3;
			break;
		case 1://using market data from period 2004 to 2007
			crdtPredefinedExpectedReturns = DefiinedStateReturns.OMBAX_ExpectedReturns2004_7;
			eqtyPredefinedExpectedReturns = DefiinedStateReturns.SP500_ExpectedReturns2004_7;
			break;
		case 2://using market data from the full range of periods
			crdtPredefinedExpectedReturns = DefiinedStateReturns.OMBAX_ExpectedReturnsFull;
			eqtyPredefinedExpectedReturns = DefiinedStateReturns.SP500_ExpectedReturnsFull;
			break;
		default://default to using market data from period 2000 to 2003
			crdtPredefinedExpectedReturns = DefiinedStateReturns.OMBAX_ExpectedReturns2000_3;
			eqtyPredefinedExpectedReturns = DefiinedStateReturns.SP500_ExpectedReturns2000_3;
			break;
		}
	}
	
	
	
	/**
	 * set the value of the predefined transition probability space
	 * this is for stochastically generated transition probabilities
	 * @param decisionAnalysisPeriod
	 */
	public void setJointTransitionProbabilityMatrix(List<AdjacencyMatrixContainer> STOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX_LIST){
		
		JOINED_PROBABILITYMATRIX_LIST = STOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX_LIST;
	}
	
	
	/**
	 * set the value of the credit and equity expected return arrays based on stochastically generated 
	 * series
	 * @param decisionAnalysisPeriod
	 */
	public void setAssetClassesExpectedReturns(double[] assetTraditionalAverageReturns, double[] assetCreditAverageReturns){
		this.eqtyPredefinedExpectedReturns = assetTraditionalAverageReturns;
		this.crdtPredefinedExpectedReturns = assetCreditAverageReturns;
	}
	
	
	//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<DEFAULT MODEL 2: TWO RISKY ASSETS WITH CASH>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	/**
	 * This method creates the set of portfolio asset states. this does not include the weighting of each asset
	 * just the combination of the assets and the possible states each can be in with the expected returns in each
	 * of those states  
	 * 
	 * Note unlike the default states creation method this method contains a cash/risk-free asset with an assumed constant
	 * rate hence having no direction changes
	 * 
	 * @param decisionAnalysisPeriod
	 */
	public void createDefaultThreeAssetModelPortfolioAssetStates(){
		/**
		 * The constructions in this method are based on the following sample definition of
		 * an adjacency matrix container with  (int crdtAssetState, int eqtyAssetState, double[] transitionProbArray)
		 *  AdjacencyMatrixContainer.createTwoAssetAdjacencyList
		 * (-1,-1, new double[] {0.169666228,0.002648894,0.166423617,0.110102552,0.001718963, 
		 * 0.107998304, 0.221107585, 0.003452016, 0.216881841})
		 */
		int eqtyDir;
		int crdtDir;
		int cshDir = 1;//set to zero as the risk free asset is assumed to have no risk and so has a constant rate of return 
		
		/**
		 * Create the portfolio asset states and add to the <PortfolioAssetsState> StateSet
		 * 
		 * createDefaultTwoAssetChoiceModelMDPState(int equityStateLevel, int creditStateLevel, 
			AssetState equityState, AssetState creditState)
		 */
		for(int i = 0; i<this.JOINED_PROBABILITYMATRIX_LIST.size(); i++){
			//get the equity asset level for the state
			eqtyDir = (int) JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getAssetTwoState();
			//get the credit asset level for the state
			crdtDir = (int) JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getAssetOneState();
			//get the transition probabilities for the state
			double[] transition =  JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getStateTransitionProbabilities(); 
			//add to the transition probabilities to arraylist that will be used to populate the state transitions
			transitions.add(transition);
			//create the equity asset state
			EquityAssetClassState equityState = new EquityAssetClassState(eqtyDir, this.eqtyPredefinedExpectedReturns);
			//create the credit asset state
			CreditAssetClassState creditState = new CreditAssetClassState(crdtDir, this.crdtPredefinedExpectedReturns);
			//create the credit asset state
			CashAssetClassState cashState = new CashAssetClassState(crdtDir, this.riskFreeCashAssetReturn);
			//create the PortfolioAssetsState object and add it to the <PortfolioAssetsState> StateSet 
			portfolioStates.add(PortfolioAssetsState.createDefaultThreeAssetChoiceModelPortfolioAssettate(
					eqtyDir, crdtDir, cshDir, equityState, creditState, cashState));
			
		}
		/**
		 * next step is to build out the transitions between states for each of the PortfolioAssetsState objects
		 * created above. 
		 * The relevant method in the PortfolioAssetsState class is:
		 * addAdjecentListTransitionsStateProbability(AssetAllocationMDPState adjcentState, double transitionProbability)
		 * 
		 * this construction assumes that the transitions array and the portfolioAssetStates set are of the same ordering. 
		 * So 
		 * 
		 * for each state in the list of PortfolioAssetStates
		 * ----get transition probability array from transitions
		 * ------for each state in list of PortfolioAssetStates and each transition probability in the collected transition probability array
		 * ------add the state and corresponding transition probability to the highlighted PortfolioAssetState
		 * 
		 * 
		 */
		if(portfolioStates.size() == transitions.size()){//ensures that there are equal number of states and transitions
			for(int i = 0; i< portfolioStates.size(); i++){
				double[] transition = transitions.get(i);
				for(int x = 0; x < portfolioStates.size(); x++){
					portfolioStates.get(i).addAdjecentListTransitionsStateProbability(portfolioStates.get(i),
							portfolioStates.get(x), transition[x]);
				}//end adding of Adjacent State Transitions Probabilities to the current state's Transitions
			}
		}
	}//end of method definition
	
	
	
	
	
	
	public void createPortfolioAllocationMDPStates(){
//		public static MDPCapitalMarketsState createAgentLevelPortfolioAllocationMDPState(int MDPStateID, PortfolioWeights pWeights, 
//				PortfolioAssetsState pAssetState, int numAsts){
//			MDPCapitalMarketsState mdpState = new MDPCapitalMarketsState(MDPStateID, pWeights, pAssetState, numAsts);
//			return mdpState;
		if(MDPStates.isEmpty() == false){
			MDPStatesHistoy.add(this.MDPStates);
			MDPStates.clear();
		}
		System.gc();
		int stateCount = 0;
		for(int x = 0; x < this.portfolioStates.size(); x++){
			for(int l = 0; l < this.actionsSpace.size(); l++){
				PortfolioWeights pw = PortfolioWeights.createEqtyCrdtCshPorfolioWeights(
						this.actionsSpace.get(l).equityAssetWeightChoice, 
						this.actionsSpace.get(l).creditAssetWeightChoice, 
						this.actionsSpace.get(l).cashAssetWeightChoice
						);
				this.MDPStates.add(MDPCapitalMarketsState.createAgentLevelPortfolioAllocationMDPState(stateCount, pw, 
						this.portfolioStates.get(x), this.portfolioStates.get(x).getProperties().length));
				stateCount++;
			}
		}
//		System.out.println("Number of MDP States: " + MDPStates.size());
	}
	
	
	
	/**
	 * This method is constructed on the observation that once original states are created, then the population of states will never change
	 * i.e. the assumption is that all possible states of the economy or market are know. What changes from time period to time period however is the
	 * transition probability between one state and the next.
	 * 
	 * Consequently, there is only need to create one MDP Decision configuration and thus one set of state-action pairs and states and actions
	 * 
	 * This global construct can then be updated for transition probabilities and returns and distributed to all agents as the simulation progresses
	 * 
	 * 
	 * 
	 * @param STOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX_LIST
	 */
	public void updateTransitions(List<AdjacencyMatrixContainer> STOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX_LIST){
		/**
		 * back up the original joint transition probability matrix
		 * 
		 * then clear the original transition probability matrix
		 * 
		 * finally add all elements of the new joint transition probability matrix
		 * 
		 */
		JOINED_PROBABILITYMATRIX_HISTORY.add(this.JOINED_PROBABILITYMATRIX_LIST);
		this.JOINED_PROBABILITYMATRIX_LIST.clear();
		this.JOINED_PROBABILITYMATRIX_LIST.addAll(STOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX_LIST);
		
		/**
		 * 
		 * Now to update the state transition probabilities.
		 * 
		 * Loop through the new joint probability matrix and 
		 * 
		 * for each element, select the equity asset and credit asset direction/state
		 * 
		 * remember that the cash asset is by default 0 since it is assumed that cash does not fluctuate in any significant way over time and 
		 * is thus the safe harbor
		 * 
		 * also for the selected equity-credit asset state pairing collect the adjacency list of transitions
		 * 
		 * {NOTE:
		 * 
		 * The constructions in this method are based on the following sample definition of
		 * an adjacency matrix container with  (int crdtAssetState, int eqtyAssetState, double[] transitionProbArray)
		 *  AdjacencyMatrixContainer.createTwoAssetAdjacencyList
		 * (-1,-1, new double[] {0.169666228,0.002648894,0.166423617,0.110102552,0.001718963, 
		 * 0.107998304, 0.221107585, 0.003452016, 0.216881841})
		 * 
		 * }
		 * 
		 * Once done, loop through the set of all states to find the states with the selected equity-credit asset state pairing 
		 * 
		 * for every match found, first call the clearTranstions() method of that state to archive the existing probability transitions
		 * and then empty out the collection of state-to-state transition probabilities
		 * 
		 *  Now for every state in the population of all states, create a new state-to-state transition probability  from the selected state
		 *  to all other states
		 * 
		 
		 */
		int eqtyDir;
		int crdtDir;
		int cshDir = 0;//set to zero as the risk free asset is assumed to have no risk and so has a constant rate of return 
		
		for(int i = 0; i<this.JOINED_PROBABILITYMATRIX_LIST.size(); i++){
			//get the equity asset level for the state
			eqtyDir = (int) JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getAssetTwoState();
			//get the credit asset level for the state
			crdtDir = (int) JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getAssetOneState();
			//get the transition probabilities for the state
			double[] transition =  JOINED_PROBABILITYMATRIX_LIST.get(i)
					.getStateTransitionProbabilities(); 
			//
			for(int x = 0; x < this.portfolioStates.size(); x++){
				if(eqtyDir == portfolioStates.get(x).prop[1] && crdtDir == portfolioStates.get(x).prop[2]){
					portfolioStates.get(x).clearTransitions();
					for(int y = 0; y < portfolioStates.size(); y++){
						portfolioStates.get(x).addAdjecentListTransitionsStateProbability(portfolioStates.get(x), portfolioStates.get(y), transition[y]);
					}//end adding of Adjacent State Transitions Probabilities to the current state's Transitions
				}
			}
		}
//		System.gc();
	}
	
	
	
	public void updateMDPStates(int time){
		this.createPortfolioAllocationMDPStates();
		if(this.stachasticTransitions == true && (time % this.numberOfEpochs == 0)){
			/* added April 24 2014 due to the constant crashing at period 5 due to excessive
			* computation involved in updating transition probabilities
			* This condition is justified because transition probabilities are not changed when 
			* using the pre-defined transition models
			* Transition probabilities will only ever be updated when running a stochastic model of 
			* asset returns
			* 
			* This is where there is an advantage to using the Q-Learning approach as opposed to 
			* value iteration which requires a transition model
			*/ 
			this.setMDPStateTransitionsProbabilities();
//			System.out.println("setMDPStateTransitionsProbabilities @ " + Sim.getAbsoluteTime());
		}
		
	}
	
	
	
	public void setMDPStateTransitionsProbabilities(){
		/*
		 * for each MDP State, get its portfolio asset state
		 * then get the transition adjacency list for that portfolio asset state
		 * define the iterator to use to loop through the transition adjacency list
		 * collect the asset weights for the MDP state
		 * 
		 * Then for each successive portfolio asset state in the adjacency list,
		 * loop through every MDP state to find MDP states with the same portfolio asset state
		 * 
		 * if the portfolio asset state in the transitions adjacency list matches that of the newly selected MDP state
		 * collect all the asset weights of the new MDP state and compute the absolute value difference between the weights of 
		 * the new MDP state mdpSprime and the original MDP state mdpS 
		 * 
		 *  If the sum of paired combinations of the weight differences are less than the maximum permissible change in portfolio weights
		 *  then assign the transition probability corresponding to the original MDP state's portfolio asset state (ps) and the new MDP state's
		 *  portfolio asset state (psp) to the two MDP states.
		 *  
		 *  otherwise set the transition probability from the original MDP state to the new MDP state to zero.
		 *  
		 *    
		 *  
		 */
		System.gc();

		for(int i= 0; i < MDPStates.size(); i++){
			mdpS = MDPStates.get(i);
			ps = mdpS.getPortfolioAssetState();
			adjListTransition = ps.getAdjacencyListTransitions();
			itr = adjListTransition.iterator();
			mdpSEW = mdpS.getCreditAssetWeight();
			mdpSCdW = mdpS.getCreditAssetWeight();
			mdpSChW = mdpS.getCashAssetWeight();
			
			while(itr.hasNext()){
				trans = itr.next();
				psp = (PortfolioAssetsState) trans.getDestinationState();
				for(int l = 0; l < MDPStates.size(); l++){
					mdpSP = MDPStates.get(l);
					mdpPsp = mdpSP.getPortfolioAssetState();
					prob = trans.getTransitionProbability();
					if(psp.compareTo(mdpPsp)){	
						mdpSPEW = mdpSP.getCreditAssetWeight();
						mdpSPCdW = mdpSP.getCreditAssetWeight();
						mdpSPChw = mdpSP.getCashAssetWeight();
						
						eqtyDiff = Math.abs(mdpSPEW - mdpSEW);
						crdtDiff = Math.abs(mdpSPCdW - mdpSCdW);
						cshDiff = Math.abs(mdpSPChw - mdpSChW);
						
						if(
								((eqtyDiff + crdtDiff) <= (this.maximumPermissbleChangeInWeight))
								//sum of the absolute change in both credit and equity assets is less than double the max change
								||
								((eqtyDiff + cshDiff) <= (this.maximumPermissbleChangeInWeight))
								||
								((crdtDiff + cshDiff) <= (this.maximumPermissbleChangeInWeight)) 
								
								){
							MDPStates.get(i).addAdjecentListTransitionsStateProbability(mdpS, mdpSP, prob);
//							System.out.println("Transition Probability of MDP State: " + i + " to: " + l + " is: " + trans.getTransitionProbability());
						}
						else{
							MDPStates.get(i).addAdjecentListTransitionsStateProbability(mdpS, mdpSP, zero);
//							System.out.println("Transition Probability of MDP State: " + i + " to: " + l + " is: " + zero);
						}
					}
				}
			}
		}
	}
	
	/**
	 * This method updates all the state contingent expected returns for all individual assets
	 * 
	 * This updated date is then broadcast to the agents and other classes that use the information
	 * 
	 * @param assetTraditionalAverageReturns
	 * @param assetCreditAverageReturns
	 */
	public void updateIndividualAssetStateReturns(double[] assetTraditionalAverageReturns, double[] assetCreditAverageReturns){
		/**
		 * First thing is to archive the existing state contingent expected returns
		 * 
		 * Next we overwrite the old returns with the new
		 * 
		 * Since the objective of the update is not to create new but use the existing states but update the data defining them 
		 * 
		 * 
		 * 
		 * Once the house keeping is done, 
		 * 
		 * loop through the set of all portfolio asset states
		 * 
		 * for each portfolio asset state, get its contained asset states
		 * 
		 * if the selected state is an instance of EquityAssetClassState or of CreditAssetClassState then update its state returns
		 * 
		 * 
		 */
		
		setAssetClassesExpectedReturns(assetTraditionalAverageReturns, assetCreditAverageReturns);
		
		
		for(int i = 0; i< portfolioStates.size(); i++){
			
			if(portfolioStates.get(i).equityAssetClassState instanceof EquityAssetClassState
					&&
					portfolioStates.get(i).creditAssetClassState instanceof CreditAssetClassState){
				//note that since this method uses the individual asset states and not the portfolio states
				//the properties index selected must be zero i.e. prop[0]
				int returnIndexEqty =  portfolioStates.get(i).equityAssetClassState.prop[0]+1;
				int returnIndexCrd =  portfolioStates.get(i).creditAssetClassState.prop[0]+1;
				double eqytReturn = assetTraditionalAverageReturns[returnIndexEqty];
				double crdReturn = assetCreditAverageReturns[returnIndexCrd];
				portfolioStates.get(i).equityAssetClassState.setDefaultModelExtectedReturn(eqytReturn);
				portfolioStates.get(i).creditAssetClassState.setDefaultModelExtectedReturn(crdReturn);
			}
		}
	}

	
	/**
	 * This method definition is used to create the set of asset weights to be used to create the MDP model states
	 * the weights act as the basis upon which permissible actions can be defined they have no bearing on the 
	 * transitions from state to state beyond defining which subset of states will be possible
	 * 
	 * Note that weights are created as an arraylist of <PortfolioWeights> in the PortfolioWeightsFactory class
	 * based on the increments in the weightings set.
	 * 
	 * THis implementation will create a three asset portfolio weighting for equity, credit and cash asset classes
	 * 
	 * @param decisionAnalysisPeriod
	 * @param shortSelling
	 */
	public void createDefaultThreeAssetModelAssetWeights(double assetWieghtIncrements, boolean shortSelling){
		if(shortSelling == false){
			this.weights = PortfolioWeightsFactory.createThreeAssetPortfolioWeightsList(assetWieghtIncrements);
		}
	}
	

	
	/**
	 * This method creates the space of all possible actions in the MDP model.
	 * it is a simple implemetation that defines the actions as the portfolio selections 
	 * therefore an action is a combination of portfolio weights
	 * 
	 * Parameters
	 * @param maxChange
	 * @param increment
	 * 
	 * steps
	 * 1:determine if maxChange is divisible by increment. If not increase maxChange by 1 or 0.1 depending on scale
	 * 1: compute the total number of actions "actionCount"
	 * 2: loop through the total number of actions
	 * 3: at each step of the loop, add the product of the loop phase and the increment to the inverse of the maxChange
	 *    i.e. -1*maxChange + (i * increment) for  i = {0,1,2,3,4...,actionCount-1}. This algorithm doesn't work for all cases
	 *    on for increments of 0.1,0.2,0.5
	 * 
	 */
	public void createWeightChoiceActions(boolean shrtSell, ArrayList<PortfolioWeights> wgts){
		for(int i = 0; i<wgts.size(); i++){
				double eqAstWghtCh = wgts.get(i).getDefaultModelEquityWeight();
				double crdAstWghtCh = wgts.get(i).getDefaultModelCreditWeight();
				double cshAstWghtCh = wgts.get(i).getDefaultModelCashWeight();
				this.actionsSpace.add(MDPPortfolioChoiceAction.createDefaultThreeEquityCreditCashAsset(eqAstWghtCh, crdAstWghtCh,
						cshAstWghtCh, shrtSell));
		}
	}
	
	/**
	 * This model is called to initialize the infinite horizon MDP
	 * It creates
	 * 1: the probability matrix to be used
	 * 2: the expected returns associated with each state of each of the assets
	 * 3: the combined asset states set and assigns the appropriate transition probabilities
	 * 4: the population of possible portfolio weights
	 * 5: the final MDP model states sets based on the combination of the combined assets states set and the 
	 * 	  population of possible weights
	 * @param prdEndString
	 * @param shtSell
	 * @param astWghtIncr
	 * @return
	 */
	protected void initializeDefaultModel(TransitionProbabilitiesEngine tpEngine, boolean stochastic, String prdEndString, 
			boolean shtSell, int numberOfIterations, double astWghtIncr) {
		// TODO Auto-generated method stub
		this.setPeriodEnd(prdEndString);
		if(stochastic == false) {
			this.setPredefinedTransitionProbabilityMatrix(this.decisionAnalysisPeriod);
			this.setDefaultAssetClassesExpectedReturns(this.decisionAnalysisPeriod);
		} else{
			this.setJointTransitionProbabilityMatrix(tpEngine.getSTOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX());
//			System.out.println(tpEngine.getSTOCHASTIC_GENERATED_JOINED_PROBABILITYMATRIX().toString());
			this.setAssetClassesExpectedReturns(tpEngine.getAssetTraditionalAverageReturns(), tpEngine.getAssetCreditAverageReturns());
		}
		
		this.createDefaultThreeAssetModelPortfolioAssetStates();
		this.createDefaultThreeAssetModelAssetWeights(astWghtIncr,shtSell);
		this.createWeightChoiceActions(this.shortSelling, this.weights);
		this.createPortfolioAllocationMDPStates();
		this.setMDPStateTransitionsProbabilities();
	}
	
	/**
	 * Set the codifying value representing the training data to be used
	 * This will need to be amended as more data sets are introduced
	 * 
	 * @param prdEndString
	 */
	private void setPeriodEnd(String prdEndString){
		if(prdEndString == "2003"){
			this.decisionAnalysisPeriod = 0;
		} else
			if(prdEndString == "2007"){
				this.decisionAnalysisPeriod = 1;
			} else
			if(prdEndString == "Full"){
				this.decisionAnalysisPeriod = 2;
			}
	}
	
	
	/**
	 * The following method defines the reward function.
	 * Note Rewards are computed as a function:
	 *  (w(i)*(rt(i) - rt-1(i)) + w(j)*(rt(j) - rt-1(j)) + w(k)*(rt(k) - rt-1(k))) - transactionCost(i,j,k)
	 * The method takes a boolean argument representing whether a linear cost function or a quadratic cost function is used as well as a 
	 * double array consisting of all the weight changes represented by an asset allocation action. 
	 * 
	 * The method check to confirm if the cost function is linear or quadratic
	 * then computes the transaction costs as a sum of transaction costs of each asset
	 * 
	 * Note: The linear cost function factor is included in the quadratic cost function arbitrarily. There is no particular reason for this
	 * however for the most part it will be assumed they are identical
	 * @param lnCost
	 * @param deltaWeight
	 * @return
	 */
	public double getReward(PortfolioAssetsState arg0, PortfolioAssetsState arg1, MDPPortfolioChoiceAction arg2, MDPPortfolioChoiceAction arg3,
			double expectedCreditDefault, int horizon) {
		// TODO Auto-generated method stub
		double reward = 0;
		if(arg0 instanceof PortfolioAssetsState && arg1 instanceof PortfolioAssetsState 
				&& arg2 instanceof MDPPortfolioChoiceAction	 && arg3 instanceof MDPPortfolioChoiceAction){
			double eqtyWeightChange = 
					arg3.getEquityAssetWeightChoice() - arg2.getEquityAssetWeightChoice();
			double crdtWeightChange = 
					arg3.getCreditAssetWeightChoice() - arg2.getCreditAssetWeightChoice();
			double cashWeightChange = 
					arg3.getCashAssetWeightChoice() - arg2.getCashAssetWeightChoice();
			double[] weightChanges = {eqtyWeightChange, crdtWeightChange, cashWeightChange};
			
				reward = (
						arg3.getEquityAssetWeightChoice() * (((1+arg1.getEquityAssetExpectedReturn())
						- (1+arg0.getEquityAssetExpectedReturn())))
						
						+ arg3.getCreditAssetWeightChoice() 
						* (((1+arg1.getCreditAssetExpectedReturn()*expectedCreditDefault)
						- (1+arg0.getCreditAssetExpectedReturn()*expectedCreditDefault)))
						
						+ arg3.getCashAssetWeightChoice() * (((1+arg1.getCashAssetExpectedReturn())
						)))
						- getTransactionCost(this.linearCostFunction, weightChanges);
		}
//		System.out.println("reward "+ reward);
		return reward;
	}



	/**
	 * The following method defines the reward function.
	 * Note Rewards are computed as a function:
	 *  (w(i)*(rt(i) - rt-1(i)) + w(j)*(rt(j) - rt-1(j)) + w(k)*(rt(k) - rt-1(k))) - transactionCost(i,j,k)
	 * The method takes a boolean argument representing whether a linear cost function or a quadratic cost function is used as well as a 
	 * double array consisting of all the weight changes represented by an asset allocation action. 
	 * 
	 * The method check to confirm if the cost function is linear or quadratic
	 * then computes the transaction costs as a sum of transaction costs of each asset
	 * 
	 * Note: The linear cost function factor is included in the quadratic cost function arbitrarily. There is no particular reason for this
	 * however for the most part it will be assumed they are identical
	 * @param lnCost
	 * @param deltaWeight
	 * @return
	 */
	public double getReward(PortfolioAssetsState arg0, PortfolioAssetsState arg1, MDPPortfolioChoiceAction arg2,
			double expectedCreditDefault, double expectedEquityLoss, int horizon) {
		// TODO Auto-generated method stub
		double reward = 0;
		if(arg0 instanceof PortfolioAssetsState && arg1 instanceof PortfolioAssetsState 
				&& arg2 instanceof MDPPortfolioChoiceAction){
			double eqtyWeightChange = arg2.getEquityAssetWeightChoice();
			double crdtWeightChange = arg2.getCreditAssetWeightChoice();
			double cashWeightChange = arg2.getCashAssetWeightChoice();
			double[] weightChanges = {eqtyWeightChange, crdtWeightChange, cashWeightChange};
			
				reward = (
						arg2.getEquityAssetWeightChoice() * (((1+arg1.getEquityAssetExpectedReturn())
						- (1+arg0.getEquityAssetExpectedReturn())))
						
						+ arg2.getCreditAssetWeightChoice() 
						* (((1+arg1.getCreditAssetExpectedReturn()*expectedCreditDefault)
						- (1+arg0.getCreditAssetExpectedReturn()*expectedCreditDefault)))
						
						+ arg2.getCashAssetWeightChoice() * (((1+arg1.getCashAssetExpectedReturn())
						)))
						- getTransactionCost(this.linearCostFunction, weightChanges);
		}
//		System.out.println("reward "+ reward);
		return reward;
	}

	

	/**
	 * The following method defines the utility function. This is computed as the surplus earned over the decision horizon
	 * Note Rewards are computed as a function:
	 *  (w(i)*(rt(i)) + w(j)*(rt(j))) + w(k)*(rt(k))) - transactionCost(i,j,k)
	 * The method takes a boolean argument representing whether a linear cost function or a quadratic cost function is used as well as a 
	 * double array consisting of all the weight changes represented by an asset allocation action. 
	 * 
	 * The method check to confirm if the cost function is linear or quadratic
	 * then computes the transaction costs as a sum of transaction costs of each asset
	 * 
	 * Note: The linear cost function factor is included in the quadratic cost function arbitrarily. There is no particular reason for this
	 * however for the most part it will be assumed they are identical
	 * @param lnCost
	 * @param deltaWeight
	 * @return
	 */
	public double getFundingSurplusUtility(PortfolioAssetsState sPrime, MDPPortfolioChoiceAction startAction, MDPPortfolioChoiceAction newAction, int decisionHorizon, 
			int resetPeriod, double expectedCreditDefault, double expectedEquityLoss, double liabilityGrowthRate) {
		// TODO Auto-generated method stub
		double surplus = 0;
		if(sPrime instanceof PortfolioAssetsState
				&& startAction instanceof MDPPortfolioChoiceAction	 && newAction instanceof MDPPortfolioChoiceAction){
			double eqtyWeightChange = 
					newAction.getEquityAssetWeightChoice() - startAction.getEquityAssetWeightChoice();
			double crdtWeightChange = 
					newAction.getCreditAssetWeightChoice() - startAction.getCreditAssetWeightChoice();
			double cashWeightChange = 
					newAction.getCashAssetWeightChoice() - startAction.getCashAssetWeightChoice();
			
			double[] weightChanges = {eqtyWeightChange, crdtWeightChange, cashWeightChange};
			double transCost = getTransactionCost(this.linearCostFunction, weightChanges);
			
			for(int i = 1; i<= decisionHorizon; i++){
				
				double nAEW = newAction.getEquityAssetWeightChoice();
				double nSER = sPrime.getEquityAssetExpectedReturn();
				double nACW = newAction.getCreditAssetWeightChoice();
				double nSCR = sPrime.getCreditAssetExpectedReturn();
				double nACshW = newAction.getCashAssetWeightChoice();
				double nSCshR = sPrime.getCashAssetExpectedReturn();
				double eL = 1;
				double cL = 1;
				
				//sum up all earnings over the decision hirizon
				if(i <= resetPeriod){
					surplus += computeEarnings(nAEW, nSER, nACW, nSCR, nACshW, nSCshR, eL, cL) - (transCost + liabilityGrowthRate);
				}
				else {
					eL = ( 1 - expectedEquityLoss);//note that this  expectedEquityLoss is treated as the 
					//of loss given default {i.e. if agents expect losses to increase (i.e. bearish) then expectedEquityLoss > 0
					// otherwise (i.e. bullish) expectedEquityLoss < 0 
					//the default value of expectedEquityLoss = 0}
					cL = (1 + expectedCreditDefault);//note that this is plus because the expectedCreditDefault is treated as the 
					//inverse of loss given default {i.e. if agents expect defaults to increase (i.e. bearish) then expectedCreditDefault < 0
					// otherwise (i.e. bullish) expectedCreditDefault > 0 }
					surplus += computeEarnings(nAEW, nSER, nACW, nSCR, nACshW, nSCshR, eL, cL) - (transCost + liabilityGrowthRate);
				}
				
			}
		}
//		System.out.println("surplus "+ surplus);
		return surplus;
	}
	
	
	

	/**
	 * The following method defines the utility function. This is computed as the surplus earned over the decision horizon
	 * Note Rewards are computed as a function:
	 *  (w(i)*(rt(i)) + w(j)*(rt(j))) + w(k)*(rt(k))) - transactionCost(i,j,k)
	 * The method takes a boolean argument representing whether a linear cost function or a quadratic cost function is used as well as a 
	 * double array consisting of all the weight changes represented by an asset allocation action. 
	 * 
	 * The method check to confirm if the cost function is linear or quadratic
	 * then computes the transaction costs as a sum of transaction costs of each asset
	 * 
	 * Note: The linear cost function factor is included in the quadratic cost function arbitrarily. There is no particular reason for this
	 * however for the most part it will be assumed they are identical
	 * @param lnCost
	 * @param deltaWeight
	 * @return
	 */
	public double getFundingSurplusUtility(MDPCapitalMarketsState sPrime, MDPPortfolioChoiceAction action, int decisionHorizon, 
			int resetPeriod, double expectedCreditDefault, double expectedEquityLoss, double liabilityGrowthRate) {
		// TODO Auto-generated method stub
		double surplus = 0;
		if(sPrime instanceof MDPCapitalMarketsState
				 && action instanceof MDPPortfolioChoiceAction){
			double eqtyWeightChange = action.getEquityAssetWeightChoice();
			double crdtWeightChange = action.getCreditAssetWeightChoice();
			double cashWeightChange = action.getCashAssetWeightChoice();
			
			double[] weightChanges = {eqtyWeightChange, crdtWeightChange, cashWeightChange};
			double transCost = getTransactionCost(this.linearCostFunction, weightChanges);
			
			double nAEW = action.getEquityAssetWeightChoice();
			double nSER = sPrime.getEquityAssetExpectedReturn();
			double nACW = action.getCreditAssetWeightChoice();
			double nSCR = sPrime.getCreditAssetExpectedReturn();
			double nACshW = action.getCashAssetWeightChoice();
			double nSCshR = sPrime.getCashAssetExpectedReturn();
				
			surplus += computeCompoundedEarnings(decisionHorizon, resetPeriod, nAEW, nSER, nACW, nSCR, nACshW, nSCshR, expectedEquityLoss, expectedCreditDefault) 
					- Math.pow((transCost + liabilityGrowthRate),decisionHorizon);
		}
//		System.out.println("surplus "+ surplus);
		return surplus;
	}
	
	
	
	private double computeEarnings(double nAEW, double nSER, double nACW,
			double nSCR, double nACshW, double nSCshR, double eL, double cL) {
		// TODO Auto-generated method stub
		
		double earnings =  nAEW * (1+ nSER)*eL + nACW * (1+ nSCR) * cL + nACshW * (1+ nSCshR);
		
		return earnings;
		
		
	}
	
	
	private double computeCompoundedEarnings(int decHoz, int resWind, double nAEW, double nSER, double nACW,
			double nSCR, double nACshW, double nSCshR, double eL, double cL) {
		// TODO Auto-generated method stub
		double earnings = 1;
		double el = 1;
		double cl = 1;
		double eqtyReturn = 1;
		double crdtReturn = 1;
		double cshReturn = 1;
		
		for(int i = 1; i <= decHoz; i++){
			
			if(i <= resWind){
				
				eqtyReturn *= nAEW * (1+ nSER)*eL;
				crdtReturn *= nACW * (1+ nSCR) * cL;
				cshReturn *=  nACshW * (1+ nSCshR);
				
			}
			else {
				el = ( 1 - eL);//note that this  expectedEquityLoss is treated as the 
				//of loss given default {i.e. if agents expect losses to increase (i.e. bearish) then expectedEquityLoss > 0
				// otherwise (i.e. bullish) expectedEquityLoss < 0 
				//the default value of expectedEquityLoss = 0}
				cl = (1 + cL);//note that this is plus because the expectedCreditDefault is treated as the 
				//inverse of loss given default {i.e. if agents expect defaults to increase (i.e. bearish) then expectedCreditDefault < 0
				// otherwise (i.e. bullish) expectedCreditDefault > 0 }
				
				eqtyReturn *= nAEW * (1+ nSER)*eL;
				crdtReturn *= nACW * (1+ nSCR) * cL;
				cshReturn *=  nACshW * (1+ nSCshR);
				
			}
			
		}
		earnings =  eqtyReturn + crdtReturn + cshReturn;
		
		return earnings;
	}


	
	
	/**
	 * The following method computes the transaction costs.
	 * The method takes a boolean argument representing whether a linear cost function or a quadratic cost function is used as well as a 
	 * double array consisting of all the weight changes represented by an asset allocation action.
	 *  
	 * transaction cost functions
	 * Linear:
	 * TC[x(i)] = dx(i)*a
	 * 
	 * Non-linear:
	 * TC[x(i)] = dx(i)*(a+b^2)
	 * 
	 * The method check to confirm if the cost function is linear or quadratic
	 * then computes the transaction costs as a sum of transaction costs of each asset
	 * 
	 * Note: The linear cost function factor is included in the quadratic cost function arbitrarily. There is no particular reason for this
	 * however for the most part it will be assumed they are identical
	 * @param lnCost
	 * @param deltaWeight
	 * @return
	 */
	public double getTransactionCost(boolean lnCost, double[] deltaWeight){
		double transactionCost = 0;
		
		if(lnCost == true){
			for(int i = 0; i < deltaWeight.length; i++){
				transactionCost = transactionCost + deltaWeight[i]*(this.linearfactor);
			}
		}else {
			for(int i = 0; i < deltaWeight.length; i++){
				transactionCost = transactionCost + deltaWeight[i]*(this.linearfactor + Math.pow(this.quadraticfactor, 2));
			}
		}
		
		return transactionCost;
	}
	
	
	
	/**
	 * This method is used to determine the full set of reachable states given an initial state and action taken at that state
	 * 
	 * Permissible
	 *  In this implementation of the IEnvironment this method is not used since the state path is defined globally for all investors
	 * @param arg0
	 * @param arg1
	 * @return
	 */
	 public ArrayList<MDPPortfolioChoiceAction> permissibleActions(PortfolioAssetsState arg0, MDPPortfolioChoiceAction arg1) {
		// TODO Auto-generated method stub
		 ArrayList<MDPPortfolioChoiceAction> permittedActions = new ArrayList<MDPPortfolioChoiceAction>();
		
//		System.out.println("reachable Method is running....");
		
		if(arg0 instanceof PortfolioAssetsState && arg1 instanceof MDPPortfolioChoiceAction){
//			System.out.println("reachable Method Check 1 passed....");
			for(MDPPortfolioChoiceAction act : this.actionsSpace){
//				System.out.println("reachable Method Check 2 started....");
				if(isInPermisibleRange(arg1, act, this.maximumPermissbleChangeInWeight)){
					permittedActions.add(act);
				}//end of valid action determining if-statement
			}//end of state selection for-loop
		}// end of current state and action taken validation check if-statement 
		return permittedActions;
	}


	 private void printStates(ArrayList<PortfolioAssetsState> statesD){
		 for (int i = 0; i < statesD.size(); i++){
//			 System.out.println("State: " + statesD.get(i).toString());
		 }
		 
	 }
	
	//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<UTILITY METHOD>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	
	/**
	 * This method is used to determine if the portfolio weights defining a CapitalMarketsPortfolioChoiceAction are in the permissible difference range to 
	 * those defining a CapitalMarketsState
	 * THe method compares the difference in weights between the action and the state to the maximum permitted portfolio weight change
	 * if so the method returns a value of "true" otherwise it returns "false"
	 * 
	 * @param arg1
	 * @param arg0
	 * @return
	 */
	private boolean isInPermisibleRange(MDPPortfolioChoiceAction action, State state, double maxChange){
		double eqtyA = action.getEquityAssetWeightChoice();
		double crdtA = action.getCreditAssetWeightChoice();
		double cshA = action.getCashAssetWeightChoice();
		MDPCapitalMarketsState capMState = (MDPCapitalMarketsState) state;//need to case the IState to a CapitalMarketsState
		double eqtyS = capMState.equityAssetWeight;
		double crdtS = capMState.creditAssetWeight;
		double cshS = capMState.cashAssetWeight;
		
		double eqtyDiff = Math.abs(eqtyA - eqtyS);
		double crdtDiff = Math.abs(crdtA - crdtS);
		double cshDiff = Math.abs(cshA - cshS);
		
		if(
				((eqtyDiff + crdtDiff) <= (maxChange))
				||
				((eqtyDiff + cshDiff) <= (maxChange))
				||
				((crdtDiff + cshDiff) <= (maxChange))
				
				){
			return true;
		} else{
			return false;
		}
	}


	
	/**
	 * This method is used to determine if the portfolio weights defining a CapitalMarketsPortfolioChoiceAction are in the permissible difference range to 
	 * those defining a CapitalMarketsState
	 * THe method compares the difference in weights between the action and the state to the maximum permitted portfolio weight change
	 * if so the method returns a value of "true" otherwise it returns "false"
	 * 
	 * @param arg1
	 * @param arg0
	 * @return
	 */
	public boolean isInPermisibleRange(MDPPortfolioChoiceAction action, MDPPortfolioChoiceAction actionNext, double maxChange){
		double eqtyCA = action.getEquityAssetWeightChoice();
		double crdtCA = action.getCreditAssetWeightChoice();
		double cshCA = action.getCashAssetWeightChoice();


		double eqtyNA = actionNext.getEquityAssetWeightChoice();
		double crdtNA = actionNext.getCreditAssetWeightChoice();
		double cshNA = actionNext.getCashAssetWeightChoice();
			
		double eqtyDiff = Math.abs(eqtyCA - eqtyNA);
		double crdtDiff = Math.abs(crdtCA - crdtNA);
		double cshDiff = Math.abs(cshCA - cshNA);
		
		if(
				((eqtyDiff + crdtDiff) <= (maxChange))//sum of the absolute change in both credit and equity assets is less than double the max change
				||
				((eqtyDiff + cshDiff) <= (maxChange))
				||
				((crdtDiff + cshDiff) <= (maxChange))
				
				){
			return true;
		} else{
			return false;
		}
	}


}
